// Vulnerability checking for TLS configurations and cipher suites
// Uses local vulnerability database for offline checking

export interface Vulnerability {
  id: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  title: string;
  description: string;
  affectedVersions: string[];
  cveId?: string;
  recommendation: string;
}

// Known vulnerable TLS protocols
const VULNERABLE_PROTOCOLS: Record<string, Vulnerability> = {
  'SSL 2.0': {
    id: 'VULN_SSL2',
    severity: 'critical',
    title: 'SSL 2.0 Protocol Vulnerability',
    description: 'SSL 2.0 has multiple severe security flaws including weak MAC construction and lack of protection for the handshake.',
    affectedVersions: ['SSL 2.0'],
    cveId: 'CVE-2016-0800',
    recommendation: 'Disable SSL 2.0 immediately and use TLS 1.2 or TLS 1.3',
  },
  'SSL 3.0': {
    id: 'VULN_SSL3',
    severity: 'critical',
    title: 'POODLE Attack (SSL 3.0)',
    description: 'SSL 3.0 is vulnerable to the POODLE attack, allowing attackers to decrypt secure connections.',
    affectedVersions: ['SSL 3.0'],
    cveId: 'CVE-2014-3566',
    recommendation: 'Disable SSL 3.0 and use TLS 1.2 or TLS 1.3',
  },
  'TLS 1.0': {
    id: 'VULN_TLS10',
    severity: 'medium',
    title: 'TLS 1.0 Deprecated Protocol',
    description: 'TLS 1.0 is considered deprecated and has known weaknesses. Major browsers are phasing out support.',
    affectedVersions: ['TLS 1.0'],
    recommendation: 'Upgrade to TLS 1.2 or TLS 1.3 for better security',
  },
  'TLS 1.1': {
    id: 'VULN_TLS11',
    severity: 'medium',
    title: 'TLS 1.1 Deprecated Protocol',
    description: 'TLS 1.1 lacks support for modern cipher suites and is considered deprecated.',
    affectedVersions: ['TLS 1.1'],
    recommendation: 'Upgrade to TLS 1.2 or TLS 1.3',
  },
};

// Known vulnerable cipher suites
const VULNERABLE_CIPHERS: Record<string, Vulnerability> = {
  RC4: {
    id: 'VULN_RC4',
    severity: 'high',
    title: 'RC4 Cipher Vulnerability',
    description: 'RC4 has known biases and is vulnerable to statistical attacks. Deprecated by RFC 7465.',
    affectedVersions: ['All versions using RC4'],
    cveId: 'CVE-2013-2566',
    recommendation: 'Use AES-GCM or ChaCha20-Poly1305 cipher suites',
  },
  DES: {
    id: 'VULN_DES',
    severity: 'critical',
    title: 'DES/3DES Cipher Vulnerability',
    description: 'DES and 3DES have small block sizes (64-bit) making them vulnerable to birthday attacks.',
    affectedVersions: ['All versions using DES/3DES'],
    cveId: 'CVE-2016-2183',
    recommendation: 'Use AES-128 or AES-256 cipher suites',
  },
  CBC: {
    id: 'VULN_CBC',
    severity: 'medium',
    title: 'CBC Mode Cipher Weakness',
    description: 'CBC mode ciphers are vulnerable to padding oracle attacks (BEAST, Lucky13) in certain configurations.',
    affectedVersions: ['TLS 1.0', 'TLS 1.1'],
    recommendation: 'Prefer AEAD ciphers like AES-GCM or ChaCha20-Poly1305',
  },
  MD5: {
    id: 'VULN_MD5',
    severity: 'high',
    title: 'MD5 Hash Algorithm Vulnerability',
    description: 'MD5 is cryptographically broken and should not be used for security purposes.',
    affectedVersions: ['All versions'],
    recommendation: 'Use SHA-256 or SHA-384 for signatures',
  },
  'SHA-1': {
    id: 'VULN_SHA1',
    severity: 'high',
    title: 'SHA-1 Collision Vulnerability',
    description: 'SHA-1 has been proven vulnerable to collision attacks and is deprecated for certificate signatures.',
    affectedVersions: ['All versions'],
    cveId: 'CVE-2020-0002',
    recommendation: 'Use SHA-256 or SHA-384 for signatures',
  },
  'EXPORT': {
    id: 'VULN_EXPORT',
    severity: 'critical',
    title: 'EXPORT Cipher Vulnerability (FREAK)',
    description: 'Export-grade ciphers use weak 512-bit or 1024-bit keys, making them trivial to break.',
    affectedVersions: ['All versions'],
    cveId: 'CVE-2015-0204',
    recommendation: 'Disable all EXPORT cipher suites',
  },
  'NULL': {
    id: 'VULN_NULL',
    severity: 'critical',
    title: 'NULL Cipher (No Encryption)',
    description: 'NULL ciphers provide no encryption whatsoever, exposing all traffic in plaintext.',
    affectedVersions: ['All versions'],
    recommendation: 'Disable NULL ciphers immediately',
  },
  'ANON': {
    id: 'VULN_ANON',
    severity: 'critical',
    title: 'Anonymous Cipher (No Authentication)',
    description: 'Anonymous ciphers provide no authentication, enabling man-in-the-middle attacks.',
    affectedVersions: ['All versions'],
    recommendation: 'Disable anonymous cipher suites',
  },
};

// Known key size vulnerabilities
export function checkKeySize(algorithm: string, bits: number): Vulnerability | null {
  if (algorithm === 'RSA' && bits < 2048) {
    return {
      id: 'VULN_RSA_WEAK',
      severity: bits < 1024 ? 'critical' : 'high',
      title: 'Weak RSA Key Size',
      description: `RSA ${bits}-bit keys are considered weak and can be broken with sufficient computing power. NIST requires 2048-bit minimum.`,
      affectedVersions: [`RSA ${bits}-bit`],
      recommendation: 'Upgrade to RSA 2048-bit or RSA 4096-bit keys',
    };
  }

  if (algorithm === 'DSA' && bits < 2048) {
    return {
      id: 'VULN_DSA_WEAK',
      severity: 'high',
      title: 'Weak DSA Key Size',
      description: `DSA ${bits}-bit keys do not meet current security standards.`,
      affectedVersions: [`DSA ${bits}-bit`],
      recommendation: 'Upgrade to DSA 2048-bit or switch to RSA/ECDSA',
    };
  }

  if (algorithm.includes('EC') && bits < 256) {
    return {
      id: 'VULN_ECC_WEAK',
      severity: 'medium',
      title: 'Weak ECC Key Size',
      description: `Elliptic curve keys smaller than 256-bit provide insufficient security margin.`,
      affectedVersions: [`ECC ${bits}-bit`],
      recommendation: 'Use P-256, P-384, or P-521 curves',
    };
  }

  return null;
}

// Check TLS protocol for vulnerabilities
export function checkProtocol(tlsVersion: string): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];
  
  const normalizedVersion = tlsVersion.toUpperCase().trim();
  
  // Check exact matches
  if (VULNERABLE_PROTOCOLS[normalizedVersion]) {
    vulnerabilities.push(VULNERABLE_PROTOCOLS[normalizedVersion]);
  }
  
  // Check for SSL in version string
  if (normalizedVersion.includes('SSL')) {
    const sslVuln = VULNERABLE_PROTOCOLS['SSL 3.0'] || VULNERABLE_PROTOCOLS['SSL 2.0'];
    if (sslVuln && !vulnerabilities.some(v => v.id === sslVuln.id)) {
      vulnerabilities.push(sslVuln);
    }
  }

  return vulnerabilities;
}

// Check cipher suite for vulnerabilities
export function checkCipherSuite(cipherSuite: string): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];
  const normalizedCipher = cipherSuite.toUpperCase();

  // Check for vulnerable cipher components
  Object.entries(VULNERABLE_CIPHERS).forEach(([pattern, vuln]) => {
    if (normalizedCipher.includes(pattern.toUpperCase())) {
      vulnerabilities.push(vuln);
    }
  });

  return vulnerabilities;
}

// Check signature algorithm for vulnerabilities
export function checkSignatureAlgorithm(signatureAlg: string): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];
  const normalized = signatureAlg.toUpperCase();

  if (normalized.includes('MD5')) {
    vulnerabilities.push(VULNERABLE_CIPHERS['MD5']);
  }

  if (normalized.includes('SHA1') || normalized.includes('SHA-1')) {
    vulnerabilities.push(VULNERABLE_CIPHERS['SHA-1']);
  }

  return vulnerabilities;
}

// Comprehensive vulnerability check
export interface VulnerabilityReport {
  totalVulnerabilities: number;
  critical: Vulnerability[];
  high: Vulnerability[];
  medium: Vulnerability[];
  low: Vulnerability[];
  allVulnerabilities: Vulnerability[];
}

export function performComprehensiveCheck(certData: {
  tlsVersion: string;
  cipherSuite: string;
  signatureAlgorithm: string;
  publicKey: { algorithm: string; bits: number };
}): VulnerabilityReport {
  const allVulnerabilities: Vulnerability[] = [];

  // Check protocol
  allVulnerabilities.push(...checkProtocol(certData.tlsVersion));

  // Check cipher suite
  allVulnerabilities.push(...checkCipherSuite(certData.cipherSuite));

  // Check signature algorithm
  allVulnerabilities.push(...checkSignatureAlgorithm(certData.signatureAlgorithm));

  // Check key size
  const keyVuln = checkKeySize(certData.publicKey.algorithm, certData.publicKey.bits);
  if (keyVuln) {
    allVulnerabilities.push(keyVuln);
  }

  // Deduplicate by ID
  const uniqueVulns = Array.from(
    new Map(allVulnerabilities.map(v => [v.id, v])).values()
  );

  // Categorize by severity
  const critical = uniqueVulns.filter(v => v.severity === 'critical');
  const high = uniqueVulns.filter(v => v.severity === 'high');
  const medium = uniqueVulns.filter(v => v.severity === 'medium');
  const low = uniqueVulns.filter(v => v.severity === 'low');

  return {
    totalVulnerabilities: uniqueVulns.length,
    critical,
    high,
    medium,
    low,
    allVulnerabilities: uniqueVulns,
  };
}
